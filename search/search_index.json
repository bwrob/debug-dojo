{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p> \ud83c\udfe3 debug dojo, a place for zen debugging </p> <p> </p> <p>debug-dojo is a Python package providing utilities for enhanced debugging and inspection in the terminal. It leverages <code>rich</code> for beautiful output and offers helpers for side-by-side object comparison, improved tracebacks from <code>rich</code>, and easy integration with different debuggers \u2013 <code>debugpy</code>, <code>pudb</code>, <code>pdb</code>, and <code>ipdb</code>.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Convenient CLI Quickly run your code with debugging tools     enabled.</li> <li>Simple API: Install all tools or only what you need.</li> <li>Debugger integration: Quickly enable Debugpy, PuDB, PDB, or IPDB     as your default pre-configured debugger.</li> <li>Rich tracebacks: Get readable, colorized tracebacks for easier     debugging.</li> <li>Side-by-side object inspection: Visually compare Python objects,     their attributes, and methods in the terminal.</li> <li>Configuration: Easily configure the debugging tools using     <code>dojo.toml</code> or <code>pyproject.toml</code>.</li> </ul>"},{"location":"#usage","title":"Usage","text":""},{"location":"#cli","title":"CLI","text":"<p>Run your Python script with debugging tools enabled using the <code>debug-dojo</code> command:</p> <pre><code>dojo my_script.py\n</code></pre> <p>You can optionally set configuration, verbose mode, and specify the debugger type. Both script files and modules are supported:</p> <pre><code>dojo --debugger ipdb --config dojo.toml --verbose --module my_module\n</code></pre> <p>dojo can let you debug into:</p> <ul> <li>any Python script \u2013 <code>dojo my_script.py</code></li> <li>any runnable module \u2013 <code>dojo -m my_module</code></li> <li>or even an executable, <code>dojo -e my_executable</code> (like <code>pytest</code>)</li> </ul>"},{"location":"#from-the-code","title":"From the code","text":"<p>In the <code>PuDB</code> style, you can install all debugging tools and enter the debugging mode with a single command:</p> <pre><code>object_1 = {\"foo\": 1, \"bar\": 2}\nobject_2 = [1, 2, 3]\n\nimport debug_dojo.install; b()\np(object_1)  # Pretty print an object with Rich\n</code></pre>"},{"location":"#features-in-debugging-mode-when-debug_dojoinstall-is-used","title":"Features in debugging mode (when <code>debug_dojo.install</code> is used)","text":"<p>When you use <code>import debug_dojo.install; b()</code>, the following convenience functions are injected into Python\u2019s builtins, making them globally available within your debugging session:</p> <ul> <li><code>b()</code>: Sets a breakpoint using the debugger configured in <code>debug-dojo</code>. This is equivalent to calling <code>breakpoint()</code> but respects your <code>debug-dojo</code> debugger settings.</li> <li><code>p(obj)</code>: Pretty prints an object using <code>rich.print</code>, providing enhanced readability for complex data structures.</li> <li><code>i(obj)</code>: Inspects an object using <code>rich.inspect</code>, offering a detailed, colorized view of its attributes and methods.</li> <li><code>c(obj1, obj2)</code>: Compares two Python objects side-by-side using <code>debug-dojo</code>\u2019s comparison utility, highlighting differences for easier debugging.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>The package is available on PyPI and can be installed using standard Python package management tools.</p> <pre><code>pip install debug-dojo\n</code></pre> <p>For full debugger support, you might want to install optional dependencies:</p> <pre><code>pip install \"debug-dojo[all-debuggers]\"\n</code></pre> <p>You can also use <code>poetry</code> or <code>uv</code> to add it to your project:</p> <pre><code>poetry add debug-dojo\n</code></pre> <pre><code>uv add debug-dojo\n</code></pre> <p>Note that dojo most likely will not work when installed via <code>pipx</code> or <code>uvx</code>, as it relies on the current Python environment dependencies.</p>"},{"location":"DEVELOPMENT_PLAN/","title":"Development Plan","text":""},{"location":"DEVELOPMENT_PLAN/#project-goals","title":"Project Goals","text":"<p><code>debug-dojo</code> aims to provide a unified, \u201czen\u201d debugging experience for Python developers. By abstracting the differences between various backend debuggers (<code>pdb</code>, <code>ipdb</code>, <code>pudb</code>, <code>debugpy</code>) and injecting useful runtime helpers (<code>p</code>, <code>c</code>, <code>i</code>, <code>b</code>), it allows developers to focus on the problem at hand rather than the toolchain configuration.</p>"},{"location":"DEVELOPMENT_PLAN/#roadmap","title":"Roadmap","text":"<p>The development roadmap is driven by GitHub issues. Below is the prioritized list of planned work.</p>"},{"location":"DEVELOPMENT_PLAN/#features-enhancements","title":"Features &amp; Enhancements","text":"<ul> <li>[#89] Zen Notifications: System notifications for breakpoints and long-running tasks.</li> <li>[#92] Dojo Belts (Gamification): Local stats tracking for usage (bugs crushed).</li> <li>[#2] Specialized Comparers: Improve the <code>c()</code> helper to provide clearer, structural diffs for <code>list</code> and <code>dict</code> types.</li> <li>[#88] Specialized Object Inspectors: Extend inspection tools for specialized objects (Pandas, NumPy, Pydantic).</li> <li>[#90] Mini-Profiler: Lightweight profiling option wrapping <code>cProfile</code>.</li> <li>[#4] PuDB Breakpoint Management: Add functionality to manage <code>pudb</code>\u2019s saved breakpoints via tool configuration.</li> <li>[#91] Robust Crash Handler: Unified interactive crash handler (\u201cDebug it? [Y/n]\u201d).</li> <li>[#85] Enhanced UI with Rich: Leverage <code>rich</code> more extensively for interactive inspection tools during debugging sessions (e.g. better object inspectors, panels).</li> <li>[#33] Direct IPython Integration: Refactor the <code>ipdb</code> backend to potentially use <code>IPython</code>\u2019s debugger directly.</li> <li>[#87] Remote Debugging: Simplify the setup for remote debugging scenarios using <code>debugpy</code>.</li> <li>[#86] Plugin System: Design and implement a plugin system to allow users to define their own helper functions or integrations.</li> </ul>"},{"location":"DEVELOPMENT_PLAN/#maintenance-stability","title":"Maintenance &amp; Stability","text":"<ul> <li>[#82] Maintenance: Dependency Updates: Keep dependencies updated, specifically ensuring compatibility with new versions of supported debuggers.</li> <li>[#83] Stability: Environment Injection Tests: Improve test coverage for edge cases in environment injection logic (<code>_installers.py</code>).</li> <li>[#35] Coverage Enforcement: Integrate coverage reporting into the CI pipeline to ensure code quality.</li> </ul>"},{"location":"DEVELOPMENT_PLAN/#documentation-infrastructure","title":"Documentation &amp; Infrastructure","text":"<ul> <li>[#84] Documentation: Advanced Usage: Expand the documentation to include more examples of advanced configuration and usage scenarios.</li> <li>[#19] Automated Publishing Workflow: Verify and refine the GitHub Actions for publishing to PyPI and deploying GitHub Pages.</li> </ul>"},{"location":"STYLE_GUIDE/","title":"Style Guide &amp; Development Conventions","text":"<p>To maintain high code quality and consistency, <code>debug-dojo</code> adheres to strict development conventions enforced by modern Python tooling.</p>"},{"location":"STYLE_GUIDE/#core-principles","title":"Core Principles","text":"<ul> <li>Strict Typing: All code must be fully typed and pass <code>basedpyright</code> in strict mode.</li> <li>Automated Formatting: Code style is enforced by <code>ruff format</code> (Black-compatible, 88 char line limit).</li> <li>Comprehensive Linting: <code>ruff</code> is used with the <code>ALL</code> rule set (with minimal exceptions) to ensure code quality.</li> <li>Test-Driven: Changes must be accompanied by comprehensive tests using <code>pytest</code>.</li> <li>Minimal Dependencies: We strive for minimal and light dependencies. Larger or specialized dependencies should be offered as optional extras.</li> </ul>"},{"location":"STYLE_GUIDE/#tooling-workflow","title":"Tooling &amp; Workflow","text":"<p>The project uses <code>uv</code> for dependency management and <code>poethepoet</code> for task automation. Before submitting any changes, ensure all quality checks pass:</p> <pre><code>poe precommit\n</code></pre> <p>This command runs all essential checks: formatting, linting, and type checking. For auto-fixing issues:</p> <pre><code>poe fix\n</code></pre> <p>Individual checks can be run via: - Format: <code>poe format</code> - Lint: <code>poe lint</code> - Type Check: <code>poe type-check</code> - Test: <code>poe test</code> (for running tests) or <code>poe coverage</code> (for coverage report).</p>"},{"location":"STYLE_GUIDE/#git-conventions","title":"Git Conventions","text":"<p>We follow a variation of Conventional Commits:</p> <ul> <li>Format: <code>type: subject</code></li> <li>Common Types: <code>feat:</code>, <code>fix:</code>, <code>docs:</code>, <code>dev:</code>, <code>test:</code>, <code>refactor:</code>.</li> </ul> <p>Example: <pre><code>docs: document 'all-debuggers' optional dependency\ndev: separate tool configs\n</code></pre></p>"},{"location":"api-reference/","title":"API Reference","text":"<p>Debugging tools for Python.</p> <p>This module provides functions to set up debugging tools like PuDB and Rich Traceback. It checks for the availability of these tools and configures them accordingly.</p> <p>Importing this module will install the debugging tools based on the configuration. Example usage:</p> <pre><code>import debug_dojo.install\n\nb()\n</code></pre> <p>This will install the debugging tools and put debug breakpoint at this line.</p> <p>Another way to use this module is to run the desired script or module with the <code>dojo</code> command-line interface.</p> <pre><code>$ dojo --verbose --config dojo.toml target_script.py --arg_1_for_script value1\n</code></pre>"},{"location":"api-reference/#dependency-graph","title":"Dependency Graph","text":"<p>```mermaid graph TD     src.debug_dojo._installers \u2013&gt; src.debug_dojo._compare     src.debug_dojo._installers \u2013&gt; src.debug_dojo._config_models     src.debug_dojo._cli \u2013&gt; src.debug_dojo._installers     src.debug_dojo._cli \u2013&gt; src.debug_dojo._config     src.debug_dojo._cli \u2013&gt; src.debug_dojo._config_models     src.debug_dojo._config \u2013&gt; src.debug_dojo._config_models     src.debug_dojo.install \u2013&gt; src.debug_dojo._config     src.debug_dojo.install \u2013&gt; src.debug_dojo._installers     src.debug_dojo._config_models     src.debug_dojo._compare</p> <p>```</p> <p>Module for installing and configuring various debugging tools and features.</p> <p>This module provides functions to set up different debuggers (PDB, PuDB, IPDB, Debugpy) and to install enhanced debugging features like Rich Traceback, Rich Inspect, Rich Print, and a side-by-side object comparer. These installations are typically driven by the <code>DebugDojoConfig</code>.</p> <p>Utilities for side-by-side inspection and comparison of Python objects.</p> <p>This module provides functions to display attributes and methods of two objects in a visually appealing, side-by-side format in the terminal.</p> <p>Debug Dojo configuration module.</p> <p>It includes configurations for different debuggers, exception handling, and features that can be enabled or disabled.</p> <p>Dataclass models for Debug Dojo\u2019s configuration.</p> <p>This module defines the data structures used to validate and manage the configuration of debug-dojo, including settings for debuggers, exception handling, and features.</p> <p>Command-line interface for running Python scripts or modules with debugging tools.</p>"},{"location":"api-reference/#debug_dojo._installers.install_breakpoint","title":"<code>install_breakpoint(mnemonic='b')</code>","text":"<p>Inject the<code>breakpoint()</code> function into builtins under the given mnemonic.</p> <p>Parameters:</p> Name Type Description Default <code>mnemonic</code> <code>str</code> <p>The name to use for the breakpoint function in builtins.             If an empty string, the feature is not installed.</p> <code>'b'</code> <p>install_breakpoint() import builtins callable(builtins.b) True</p> Source code in <code>src/debug_dojo/_installers.py</code> <pre><code>def install_breakpoint(mnemonic: str = \"b\") -&gt; None:\n    \"\"\"Inject the`breakpoint()` function into builtins under the given mnemonic.\n\n    Args:\n        mnemonic (str): The name to use for the breakpoint function in builtins.\n                        If an empty string, the feature is not installed.\n\n    &gt;&gt;&gt; install_breakpoint()\n    &gt;&gt;&gt; import builtins\n    &gt;&gt;&gt; callable(builtins.b)\n    True\n\n    \"\"\"\n    if not mnemonic:\n        return\n\n    builtins.__dict__[mnemonic] = breakpoint\n</code></pre>"},{"location":"api-reference/#debug_dojo._installers.install_by_config","title":"<code>install_by_config(config)</code>","text":"<p>Installs all debugging tools and features based on the given configuration.</p> <p>This is the main entry point for applying <code>debug-dojo</code> settings.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>DebugDojoConfig</code> <p>The complete debug-dojo configuration object.</p> required Source code in <code>src/debug_dojo/_installers.py</code> <pre><code>def install_by_config(config: DebugDojoConfig) -&gt; None:\n    \"\"\"Installs all debugging tools and features based on the given configuration.\n\n    This is the main entry point for applying `debug-dojo` settings.\n\n    Args:\n        config (DebugDojoConfig): The complete debug-dojo configuration object.\n\n    \"\"\"\n    set_debugger(config.debuggers)\n    set_exceptions(config.exceptions)\n    install_features(config.features)\n</code></pre>"},{"location":"api-reference/#debug_dojo._installers.install_compare","title":"<code>install_compare(mnemonic='c')</code>","text":"<p>Injects the side-by-side object comparison function into builtins.</p> <p>Parameters:</p> Name Type Description Default <code>mnemonic</code> <code>str</code> <p>The name to use for the compare function in builtins.             If an empty string, the feature is not installed.</p> <code>'c'</code> <p>install_compare() import builtins callable(builtins.c) True</p> Source code in <code>src/debug_dojo/_installers.py</code> <pre><code>def install_compare(mnemonic: str = \"c\") -&gt; None:\n    \"\"\"Injects the side-by-side object comparison function into builtins.\n\n    Args:\n        mnemonic (str): The name to use for the compare function in builtins.\n                        If an empty string, the feature is not installed.\n\n    &gt;&gt;&gt; install_compare()\n    &gt;&gt;&gt; import builtins\n    &gt;&gt;&gt; callable(builtins.c)\n    True\n\n    \"\"\"\n    if not mnemonic:\n        return\n\n    builtins.__dict__[mnemonic] = inspect_objects_side_by_side\n</code></pre>"},{"location":"api-reference/#debug_dojo._installers.install_features","title":"<code>install_features(features)</code>","text":"<p>Installs debugging features based on the provided configuration.</p> <p>Parameters:</p> Name Type Description Default <code>features</code> <code>FeaturesConfig</code> <p>Configuration object specifying which features                        to install and their mnemonics.</p> required Source code in <code>src/debug_dojo/_installers.py</code> <pre><code>def install_features(features: FeaturesConfig) -&gt; None:\n    \"\"\"Installs debugging features based on the provided configuration.\n\n    Args:\n        features (FeaturesConfig): Configuration object specifying which features\n                                   to install and their mnemonics.\n\n    \"\"\"\n    install_inspect(features.rich_inspect)\n    install_rich_print(features.rich_print)\n    install_compare(features.comparer)\n    install_breakpoint(features.breakpoint)\n</code></pre>"},{"location":"api-reference/#debug_dojo._installers.install_inspect","title":"<code>install_inspect(mnemonic='i')</code>","text":"<p>Injects <code>rich.inspect</code> into builtins under the given mnemonic.</p> <p>Parameters:</p> Name Type Description Default <code>mnemonic</code> <code>str</code> <p>The name to use for the inspect function in builtins.             If an empty string, the feature is not installed.</p> <code>'i'</code> Source code in <code>src/debug_dojo/_installers.py</code> <pre><code>def install_inspect(mnemonic: str = \"i\") -&gt; None:\n    \"\"\"Injects `rich.inspect` into builtins under the given mnemonic.\n\n    Args:\n        mnemonic (str): The name to use for the inspect function in builtins.\n                        If an empty string, the feature is not installed.\n\n    \"\"\"\n    if not mnemonic:\n        return\n\n    from rich import inspect\n\n    def inspect_with_defaults(obj: object, **kwargs: bool) -&gt; None:\n        \"\"\"Inspect an object using Rich's inspect function.\"\"\"\n        if not kwargs:\n            kwargs = {\"methods\": True, \"private\": True}\n        return inspect(obj, console=None, title=\"\", **kwargs)\n\n    builtins.__dict__[mnemonic] = inspect_with_defaults\n</code></pre>"},{"location":"api-reference/#debug_dojo._installers.install_rich_print","title":"<code>install_rich_print(mnemonic='p')</code>","text":"<p>Injects <code>rich.print</code> into builtins under the given mnemonic.</p> <p>Parameters:</p> Name Type Description Default <code>mnemonic</code> <code>str</code> <p>The name to use for the print function in builtins.             If an empty string, the feature is not installed.</p> <code>'p'</code> <p>install_rich_print() import builtins callable(builtins.p) True p(\u201ctest\u201d) test</p> Source code in <code>src/debug_dojo/_installers.py</code> <pre><code>def install_rich_print(mnemonic: str = \"p\") -&gt; None:\n    \"\"\"Injects `rich.print` into builtins under the given mnemonic.\n\n    Args:\n        mnemonic (str): The name to use for the print function in builtins.\n                        If an empty string, the feature is not installed.\n\n    &gt;&gt;&gt; install_rich_print()\n    &gt;&gt;&gt; import builtins\n    &gt;&gt;&gt; callable(builtins.p)\n    True\n    &gt;&gt;&gt; p(\"test\")\n    test\n\n    \"\"\"\n    if not mnemonic:\n        return\n\n    from rich import print as rich_print\n\n    builtins.__dict__[mnemonic] = rich_print\n</code></pre>"},{"location":"api-reference/#debug_dojo._installers.rich_traceback","title":"<code>rich_traceback(*, locals_in_traceback)</code>","text":"<p>Install Rich Traceback for enhanced error reporting.</p> <p>Parameters:</p> Name Type Description Default <code>locals_in_traceback</code> <code>bool</code> <p>Whether to include local variables in the traceback.</p> required Source code in <code>src/debug_dojo/_installers.py</code> <pre><code>def rich_traceback(*, locals_in_traceback: bool) -&gt; None:\n    \"\"\"Install Rich Traceback for enhanced error reporting.\n\n    Args:\n        locals_in_traceback (bool): Whether to include local variables in the traceback.\n\n    \"\"\"\n    from rich import traceback\n\n    _ = traceback.install(show_locals=locals_in_traceback)\n</code></pre>"},{"location":"api-reference/#debug_dojo._installers.set_debugger","title":"<code>set_debugger(config)</code>","text":"<p>Set the default debugger based on the provided configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>DebuggersConfig</code> <p>Configuration object for debuggers.</p> required Source code in <code>src/debug_dojo/_installers.py</code> <pre><code>def set_debugger(config: DebuggersConfig) -&gt; None:\n    \"\"\"Set the default debugger based on the provided configuration.\n\n    Args:\n        config (DebuggersConfig): Configuration object for debuggers.\n\n    \"\"\"\n    debugger = config.default\n\n    if debugger == DebuggerType.PDB:\n        use_pdb(config.pdb)\n    if debugger == DebuggerType.PUDB:\n        use_pudb(config.pudb)\n    if debugger == DebuggerType.IPDB:\n        use_ipdb(config.ipdb)\n    if debugger == DebuggerType.DEBUGPY:\n        use_debugpy(config.debugpy)\n\n    sys.ps1 = config.prompt_name\n</code></pre>"},{"location":"api-reference/#debug_dojo._installers.set_exceptions","title":"<code>set_exceptions(exceptions)</code>","text":"<p>Configure exception handling based on the provided configuration.</p> <p>Parameters:</p> Name Type Description Default <code>exceptions</code> <code>ExceptionsConfig</code> <p>Configuration object for exception handling.</p> required Source code in <code>src/debug_dojo/_installers.py</code> <pre><code>def set_exceptions(exceptions: ExceptionsConfig) -&gt; None:\n    \"\"\"Configure exception handling based on the provided configuration.\n\n    Args:\n        exceptions (ExceptionsConfig): Configuration object for exception handling.\n\n    \"\"\"\n    if exceptions.rich_traceback:\n        rich_traceback(locals_in_traceback=exceptions.locals_in_traceback)\n</code></pre>"},{"location":"api-reference/#debug_dojo._installers.use_debugpy","title":"<code>use_debugpy(config)</code>","text":"<p>Set Debugpy as the default debugger.</p> <p>Configures <code>sys.breakpointhook</code> to use <code>debugpy.breakpoint</code>, sets the <code>PYTHONBREAKPOINT</code> environment variable, and starts a debugpy server waiting for a client connection.</p> Source code in <code>src/debug_dojo/_installers.py</code> <pre><code>def use_debugpy(config: DebugpyConfig) -&gt; None:\n    \"\"\"Set Debugpy as the default debugger.\n\n    Configures `sys.breakpointhook` to use `debugpy.breakpoint`, sets the\n    `PYTHONBREAKPOINT` environment variable, and starts a debugpy server\n    waiting for a client connection.\n    \"\"\"\n    try:\n        import debugpy  # pyright: ignore[reportMissingTypeStubs]\n    except ImportError:\n        rich_print(_NOT_INSTALLED.format(name=\"Debugpy\"))\n        return\n\n    os.environ[BREAKPOINT_ENV_VAR] = config.set_trace_hook\n    sys.breakpointhook = debugpy.breakpoint\n\n    launch_config = {\n        \"name\": \"debug-dojo\",\n        \"type\": \"debugpy\",\n        \"request\": \"attach\",\n        \"connect\": {\n            \"host\": config.host,\n            \"port\": config.port,\n        },\n    }\n    rich_print(f\"[blue]Connect your VSC debugger to port {config.port}.[/blue]\")\n    rich_print(\"[blue]Configuration:[/blue]\")\n    rich_print(json.dumps(launch_config, indent=4))\n\n    _ = debugpy.listen((config.host, config.port))\n    debugpy.wait_for_client()\n</code></pre>"},{"location":"api-reference/#debug_dojo._installers.use_ipdb","title":"<code>use_ipdb(config)</code>","text":"<p>Set IPDB as the default debugger.</p> <p>Configures <code>sys.breakpointhook</code> to use <code>ipdb.set_trace</code>, sets the <code>PYTHONBREAKPOINT</code> environment variable, and configures <code>IPDB_CONTEXT_SIZE</code>.</p> Source code in <code>src/debug_dojo/_installers.py</code> <pre><code>def use_ipdb(config: IpdbConfig) -&gt; None:\n    \"\"\"Set IPDB as the default debugger.\n\n    Configures `sys.breakpointhook` to use `ipdb.set_trace`, sets the\n    `PYTHONBREAKPOINT` environment variable, and configures `IPDB_CONTEXT_SIZE`.\n    \"\"\"\n    try:\n        import ipdb  # pyright: ignore[reportMissingTypeStubs]\n    except ImportError:\n        rich_print(_NOT_INSTALLED.format(name=\"IPDB\"))\n        return\n\n    os.environ[BREAKPOINT_ENV_VAR] = config.set_trace_hook\n    os.environ[IPDB_CONTEXT_SIZE] = str(config.context_lines)\n    sys.breakpointhook = ipdb.set_trace  # pyright: ignore[reportUnknownMemberType]\n</code></pre>"},{"location":"api-reference/#debug_dojo._installers.use_pdb","title":"<code>use_pdb(config)</code>","text":"<p>Set PDB as the default debugger.</p> <p>Configures <code>sys.breakpointhook</code> to use <code>pdb.set_trace</code> and sets the <code>PYTHONBREAKPOINT</code> environment variable.</p> Source code in <code>src/debug_dojo/_installers.py</code> <pre><code>def use_pdb(config: PdbConfig) -&gt; None:\n    \"\"\"Set PDB as the default debugger.\n\n    Configures `sys.breakpointhook` to use `pdb.set_trace` and sets the\n    `PYTHONBREAKPOINT` environment variable.\n    \"\"\"\n    import pdb\n\n    os.environ[BREAKPOINT_ENV_VAR] = config.set_trace_hook\n    sys.breakpointhook = pdb.set_trace\n</code></pre>"},{"location":"api-reference/#debug_dojo._installers.use_pudb","title":"<code>use_pudb(config)</code>","text":"<p>Set PuDB as the default debugger.</p> <p>Configures <code>sys.breakpointhook</code> to use <code>pudb.set_trace</code> and sets the <code>PYTHONBREAKPOINT</code> environment variable.</p> Source code in <code>src/debug_dojo/_installers.py</code> <pre><code>def use_pudb(config: PudbConfig) -&gt; None:\n    \"\"\"Set PuDB as the default debugger.\n\n    Configures `sys.breakpointhook` to use `pudb.set_trace` and sets the\n    `PYTHONBREAKPOINT` environment variable.\n    \"\"\"\n    try:\n        import pudb  # pyright: ignore[reportMissingTypeStubs]\n    except ImportError:\n        rich_print(_NOT_INSTALLED.format(name=\"PuDB\"))\n        return\n\n    os.environ[BREAKPOINT_ENV_VAR] = config.set_trace_hook\n    sys.breakpointhook = pudb.set_trace\n</code></pre>"},{"location":"api-reference/#debug_dojo._compare.get_object_attributes","title":"<code>get_object_attributes(obj)</code>","text":"<p>Extract and format non-callable attributes of an object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The object to extract attributes from.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of formatted strings, each representing an attribute.</p> Source code in <code>src/debug_dojo/_compare.py</code> <pre><code>def get_object_attributes(obj: object) -&gt; list[str]:\n    \"\"\"Extract and format non-callable attributes of an object.\n\n    Args:\n        obj (object): The object to extract attributes from.\n\n    Returns:\n        list[str]: A list of formatted strings, each representing an attribute.\n\n    \"\"\"\n    attributes: list[str] = []\n    for attr_name in sorted(dir(obj)):\n        # Safely get attribute, returning None if it doesn't exist\n        attr = getattr(obj, attr_name, None)\n        # Exclude dunder methods and callable attributes\n        if not attr_name.startswith(\"__\") and not callable(attr):\n            with contextlib.suppress(AttributeError):\n                # Use !r for robust string representation of the attribute value\n                attributes.append(f\"{attr_name}={attr!r}\")\n    return attributes\n</code></pre>"},{"location":"api-reference/#debug_dojo._compare.get_object_methods","title":"<code>get_object_methods(obj)</code>","text":"<p>Extract and format public callable methods of an object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The object to extract methods from.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of method names.</p> Source code in <code>src/debug_dojo/_compare.py</code> <pre><code>def get_object_methods(obj: object) -&gt; list[str]:\n    \"\"\"Extract and format public callable methods of an object.\n\n    Args:\n        obj (object): The object to extract methods from.\n\n    Returns:\n        list[str]: A list of method names.\n\n    \"\"\"\n    methods: list[str] = []\n    for method_name in sorted(dir(obj)):\n        # Safely get attribute, returning None if it doesn't exist\n        attr = getattr(obj, method_name, None)\n        # Exclude private/protected methods (starting with '_') and non-callables.\n        if not method_name.startswith(\"_\") and callable(attr):\n            methods.append(method_name)\n    return methods\n</code></pre>"},{"location":"api-reference/#debug_dojo._compare.get_simplified_object_info","title":"<code>get_simplified_object_info(obj)</code>","text":"<p>Generate a simplified, Rich-formatted inspection output for an object.</p> <p>Handles basic Python types by displaying their value directly. For other objects, it lists their attributes and public methods.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The object to generate info for.</p> required <p>Returns:</p> Type Description <code>list[Text]</code> <p>list[Text]: A list of Rich Text objects representing the object\u2019s information.</p> Source code in <code>src/debug_dojo/_compare.py</code> <pre><code>def get_simplified_object_info(obj: object) -&gt; list[Text]:\n    \"\"\"Generate a simplified, Rich-formatted inspection output for an object.\n\n    Handles basic Python types by displaying their value directly. For other objects, it\n    lists their attributes and public methods.\n\n    Args:\n        obj (object): The object to generate info for.\n\n    Returns:\n        list[Text]: A list of Rich Text objects representing the object's information.\n\n    \"\"\"\n    info_lines: list[Text] = []\n    obj_type: str = type(obj).__name__\n    info_lines.append(Text(f\"&lt;class '{obj_type}'&gt;\", style=\"cyan bold\"))\n    info_lines.append(Text(\"\"))\n\n    # Handle basic data types by displaying their value directly\n    if isinstance(obj, (str, int, float, list, dict, tuple, set, bool)) or obj is None:\n        info_lines.append(Text(\"Value:\", style=\"bold\"))\n        info_lines.append(Text(f\"  {obj!r}\", style=\"yellow\"))\n        info_lines.append(Text(\"\"))\n        info_lines.append(\n            Text(\"No attributes or methods to display for this type.\", style=\"dim\")\n        )\n        return info_lines\n\n    # For other objects, list attributes\n    attributes = get_object_attributes(obj)\n    if attributes:\n        info_lines.append(Text(\"Attributes:\", style=\"bold\"))\n        info_lines.extend([Text(f\"  {attr}\") for attr in attributes])\n    else:\n        info_lines.append(Text(\"No attributes found.\", style=\"dim\"))\n    info_lines.append(Text(\"\"))\n\n    # List methods\n    methods = get_object_methods(obj)\n    if methods:\n        info_lines.append(Text(\"Methods:\", style=\"bold\"))\n        info_lines.extend([Text(f\"  {method}()\") for method in methods])\n    else:\n        info_lines.append(Text(\"No public methods found.\", style=\"dim\"))\n\n    return info_lines\n</code></pre>"},{"location":"api-reference/#debug_dojo._compare.inspect_objects_side_by_side","title":"<code>inspect_objects_side_by_side(obj1, obj2)</code>","text":"<p>Display two Python objects side-by-side in the terminal using Rich.</p> <p>Showing their attributes and methods in a simplified, aligned format.</p> <p>Parameters:</p> Name Type Description Default <code>obj1</code> <code>object</code> <p>The first object to display.</p> required <code>obj2</code> <code>object</code> <p>The second object to display.</p> required Source code in <code>src/debug_dojo/_compare.py</code> <pre><code>def inspect_objects_side_by_side(\n    obj1: object,\n    obj2: object,\n) -&gt; None:\n    \"\"\"Display two Python objects side-by-side in the terminal using Rich.\n\n    Showing their attributes and methods in a simplified, aligned format.\n\n    Args:\n        obj1 (object): The first object to display.\n        obj2 (object): The second object to display.\n\n    \"\"\"\n    main_console: Console = Console()\n\n    lines1: list[Text] = get_simplified_object_info(obj1)\n    lines2: list[Text] = get_simplified_object_info(obj2)\n\n    # Determine the maximum number of lines to ensure consistent height\n    max_lines: int = max(len(lines1), len(lines2))\n\n    # Pad the shorter list of lines with empty Text objects to match the height\n    if len(lines1) &lt; max_lines:\n        lines1.extend([Text(\"\")] * (max_lines - len(lines1)))\n    if len(lines2) &lt; max_lines:\n        lines2.extend([Text(\"\")] * (max_lines - len(lines2)))\n\n    # Join the padded lines into a single Text object for the Panel content\n    padded_inspect_text1: Text = Text(\"\\n\").join(lines1)\n    padded_inspect_text2: Text = Text(\"\\n\").join(lines2)\n\n    panel1: Panel = Panel(padded_inspect_text1, border_style=\"green\", expand=True)\n    panel2: Panel = Panel(padded_inspect_text2, border_style=\"green\", expand=True)\n\n    main_console.print(Columns([panel1, panel2]))\n</code></pre>"},{"location":"api-reference/#debug_dojo._config.load_config","title":"<code>load_config(config_path=None, *, verbose=False, debugger=None)</code>","text":"<p>Load the Debug Dojo configuration.</p> <p>Return a DebugDojoConfig instance with the loaded configuration.</p> <p>If no configuration file is found, it returns a default configuration. If a debugger is specified, it overrides the config.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Path | None</code> <p>Optional path to a configuration file.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If True, print verbose messages during configuration loading.</p> <code>False</code> <code>debugger</code> <code>DebuggerType | None</code> <p>Optional debugger type to override the default                             debugger specified in the configuration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>DebugDojoConfig</code> <code>DebugDojoConfig</code> <p>The loaded and potentially overridden DebugDojoConfig instance.</p> Source code in <code>src/debug_dojo/_config.py</code> <pre><code>def load_config(\n    config_path: Path | None = None,\n    *,\n    verbose: bool = False,\n    debugger: DebuggerType | None = None,\n) -&gt; DebugDojoConfig:\n    \"\"\"Load the Debug Dojo configuration.\n\n    Return a DebugDojoConfig instance with the loaded configuration.\n\n    If no configuration file is found, it returns a default configuration. If a debugger\n    is specified, it overrides the config.\n\n    Args:\n        config_path (Path | None): Optional path to a configuration file.\n        verbose (bool): If True, print verbose messages during configuration loading.\n        debugger (DebuggerType | None): Optional debugger type to override the default\n                                        debugger specified in the configuration.\n\n    Returns:\n        DebugDojoConfig: The loaded and potentially overridden DebugDojoConfig instance.\n\n    \"\"\"\n    resolved_path = resolve_config_path(config_path)\n\n    if verbose:\n        if resolved_path:\n            msg = f\"Using configuration file: {resolved_path}.\"\n        else:\n            msg = \"No configuration file found, using default settings.\"\n        rich_print(f\"[blue]{msg}[/blue]\")\n\n    if not resolved_path:\n        return DebugDojoConfig()\n\n    raw_config = load_raw_config(resolved_path)\n    config = validated_and_updated_config(raw_config, verbose=verbose)\n\n    # If a debugger is specified, override the config.\n    if debugger:\n        config.debuggers.default = debugger\n\n    return config\n</code></pre>"},{"location":"api-reference/#debug_dojo._config.load_raw_config","title":"<code>load_raw_config(config_path)</code>","text":"<p>Load the Debug Dojo configuration from a file.</p> <p>Currently supports \u2018dojo.toml\u2019 or \u2018pyproject.toml\u2019. If no path is provided, it checks the current directory for these files.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Path</code> <p>The absolute path to the configuration file.</p> required <p>Returns:</p> Name Type Description <code>JSON</code> <code>JSON</code> <p>The raw configuration data as a JSON-like dictionary.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there is an error parsing the TOML file.</p> Source code in <code>src/debug_dojo/_config.py</code> <pre><code>def load_raw_config(config_path: Path) -&gt; JSON:\n    \"\"\"Load the Debug Dojo configuration from a file.\n\n    Currently supports 'dojo.toml' or 'pyproject.toml'. If no path is provided, it\n    checks the current directory for these files.\n\n    Args:\n        config_path (Path): The absolute path to the configuration file.\n\n    Returns:\n        JSON: The raw configuration data as a JSON-like dictionary.\n\n    Raises:\n        ValueError: If there is an error parsing the TOML file.\n\n    \"\"\"\n    config_str = config_path.read_text(encoding=\"utf-8\")\n\n    try:\n        config_data = parse(config_str).unwrap()\n    except TOMLKitError as e:\n        msg = f\"Error parsing configuration file {config_path.resolve()}..\"\n        raise ValueError(msg) from e\n\n    if config_path.name != \"pyproject.toml\":\n        return config_data\n\n    # If config is in [tool.debug_dojo] (pyproject.toml), extract it.\n    try:\n        dojo_config = cast(\"JSON\", config_data[\"tool\"][\"debug_dojo\"])\n    except KeyError:\n        return {}\n    else:\n        return dojo_config\n</code></pre>"},{"location":"api-reference/#debug_dojo._config.resolve_config_path","title":"<code>resolve_config_path(config_path)</code>","text":"<p>Resolve the configuration path.</p> <p>Returning a default if none is provided.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Path | None</code> <p>The explicit path to the configuration file, or None.</p> required <p>Returns:</p> Type Description <code>Path | None</code> <p>Path | None: The resolved absolute path to the configuration file, or None if no          configuration file is found and no explicit path was given.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If an explicit <code>config_path</code> is provided but the file                does not exist.</p> Source code in <code>src/debug_dojo/_config.py</code> <pre><code>def resolve_config_path(config_path: Path | None) -&gt; Path | None:\n    \"\"\"Resolve the configuration path.\n\n    Returning a default if none is provided.\n\n    Args:\n        config_path (Path | None): The explicit path to the configuration file, or None.\n\n    Returns:\n        Path | None: The resolved absolute path to the configuration file, or None if no\n                     configuration file is found and no explicit path was given.\n\n    Raises:\n        FileNotFoundError: If an explicit `config_path` is provided but the file\n                           does not exist.\n\n    \"\"\"\n    if config_path:\n        if not config_path.exists():\n            msg = f\"Configuration file not found:\\n{config_path.resolve()}\"\n            raise FileNotFoundError(msg)\n        return config_path.resolve()\n\n    # Default configuration path\n    for path in (Path(\"dojo.toml\"), Path(\"pyproject.toml\")):\n        if path.exists():\n            return path.resolve()\n\n    # None means - use default config values\n    return None\n</code></pre>"},{"location":"api-reference/#debug_dojo._config.validated_and_updated_config","title":"<code>validated_and_updated_config(raw_config, *, verbose)</code>","text":"<p>Validate and update the raw configuration to the latest DebugDojoConfig version.</p> <p>Parameters:</p> Name Type Description Default <code>raw_config</code> <code>JSON</code> <p>The raw configuration data loaded from a file.</p> required <code>verbose</code> <code>bool</code> <p>If True, print verbose messages during validation and update.</p> required <p>Returns:</p> Name Type Description <code>DebugDojoConfig</code> <code>DebugDojoConfig</code> <p>A validated and updated DebugDojoConfig instance.</p> <p>Raises:</p> Type Description <code>Exit</code> <p>If the configuration cannot be validated against any known version.</p> Source code in <code>src/debug_dojo/_config.py</code> <pre><code>def validated_and_updated_config(raw_config: JSON, *, verbose: bool) -&gt; DebugDojoConfig:\n    \"\"\"Validate and update the raw configuration to the latest DebugDojoConfig version.\n\n    Args:\n        raw_config (JSON): The raw configuration data loaded from a file.\n        verbose (bool): If True, print verbose messages during validation and update.\n\n    Returns:\n        DebugDojoConfig: A validated and updated DebugDojoConfig instance.\n\n    Raises:\n        typer.Exit: If the configuration cannot be validated against any known version.\n\n    \"\"\"\n    config: DebugDojoConfigV1 | DebugDojoConfigV2 | None = None\n\n    for model in (DebugDojoConfigV2, DebugDojoConfigV1):\n        model_name = model.__name__\n        try:\n            config = _validate_model(model, raw_config)\n        except (DaciteError, TypeError, ValueError) as e:\n            if verbose:\n                msg = (\n                    f\"[yellow]Configuration validation error for {model_name}:\\n{e}\\n\\n\"\n                )\n                rich_print(msg)\n        else:\n            if verbose or model_name != DebugDojoConfig.__name__:\n                msg = (\n                    f\"[blue]Using configuration model: {model_name}.\\n\"\n                    f\"Current configuration model {DebugDojoConfig.__name__}. [/blue]\"\n                )\n                rich_print(msg)\n            break\n\n    if not config:\n        msg = \"[red]Unsupported configuration version or error.[/red]\"\n        rich_print(msg)\n        raise Exit(code=1)\n\n    while not isinstance(config, DebugDojoConfig):\n        config = config.update()\n\n    return config\n</code></pre>"},{"location":"api-reference/#debug_dojo._config_models.DebugDojoConfigV1","title":"<code>DebugDojoConfigV1</code>  <code>dataclass</code>","text":"<p>Legacy configuration for Debug Dojo (version 1).</p> Source code in <code>src/debug_dojo/_config_models.py</code> <pre><code>@dataclass\nclass DebugDojoConfigV1:\n    \"\"\"Legacy configuration for Debug Dojo (version 1).\"\"\"\n\n    debugger: DebuggerType = DebuggerType.PUDB\n    \"\"\"The type of debugger to use.\"\"\"\n    features: Features = field(default_factory=Features)\n    \"\"\"Features to install for debugging.\"\"\"\n\n    def update(self) -&gt; DebugDojoConfigV2:\n        \"\"\"Update the configuration to the latest version.\"\"\"\n        v2_exceptions = ExceptionsConfig(\n            rich_traceback=self.features.rich_traceback,\n        )\n        v2_debuggers = DebuggersConfig(default=self.debugger)\n        v2_features = FeaturesConfig(\n            rich_inspect=\"i\" if self.features.rich_inspect else \"\",\n            rich_print=\"p\" if self.features.rich_print else \"\",\n            comparer=\"c\" if self.features.comparer else \"\",\n            breakpoint=\"b\" if self.features.breakpoint else \"\",\n        )\n        return DebugDojoConfigV2(\n            exceptions=v2_exceptions,\n            debuggers=v2_debuggers,\n            features=v2_features,\n        )\n</code></pre>"},{"location":"api-reference/#debug_dojo._config_models.DebugDojoConfigV1.debugger","title":"<code>debugger = DebuggerType.PUDB</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The type of debugger to use.</p>"},{"location":"api-reference/#debug_dojo._config_models.DebugDojoConfigV1.features","title":"<code>features = field(default_factory=Features)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Features to install for debugging.</p>"},{"location":"api-reference/#debug_dojo._config_models.DebugDojoConfigV1.update","title":"<code>update()</code>","text":"<p>Update the configuration to the latest version.</p> Source code in <code>src/debug_dojo/_config_models.py</code> <pre><code>def update(self) -&gt; DebugDojoConfigV2:\n    \"\"\"Update the configuration to the latest version.\"\"\"\n    v2_exceptions = ExceptionsConfig(\n        rich_traceback=self.features.rich_traceback,\n    )\n    v2_debuggers = DebuggersConfig(default=self.debugger)\n    v2_features = FeaturesConfig(\n        rich_inspect=\"i\" if self.features.rich_inspect else \"\",\n        rich_print=\"p\" if self.features.rich_print else \"\",\n        comparer=\"c\" if self.features.comparer else \"\",\n        breakpoint=\"b\" if self.features.breakpoint else \"\",\n    )\n    return DebugDojoConfigV2(\n        exceptions=v2_exceptions,\n        debuggers=v2_debuggers,\n        features=v2_features,\n    )\n</code></pre>"},{"location":"api-reference/#debug_dojo._config_models.DebugDojoConfigV2","title":"<code>DebugDojoConfigV2</code>  <code>dataclass</code>","text":"<p>Configuration for Debug Dojo.</p> Source code in <code>src/debug_dojo/_config_models.py</code> <pre><code>@dataclass\nclass DebugDojoConfigV2:\n    \"\"\"Configuration for Debug Dojo.\"\"\"\n\n    exceptions: ExceptionsConfig = field(default_factory=ExceptionsConfig)\n    \"\"\"Better exception messages.\"\"\"\n    debuggers: DebuggersConfig = field(default_factory=DebuggersConfig)\n    \"\"\"Default debugger and configs.\"\"\"\n    features: FeaturesConfig = field(default_factory=FeaturesConfig)\n    \"\"\"Features mnemonics.\"\"\"\n</code></pre>"},{"location":"api-reference/#debug_dojo._config_models.DebugDojoConfigV2.debuggers","title":"<code>debuggers = field(default_factory=DebuggersConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default debugger and configs.</p>"},{"location":"api-reference/#debug_dojo._config_models.DebugDojoConfigV2.exceptions","title":"<code>exceptions = field(default_factory=ExceptionsConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Better exception messages.</p>"},{"location":"api-reference/#debug_dojo._config_models.DebugDojoConfigV2.features","title":"<code>features = field(default_factory=FeaturesConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Features mnemonics.</p>"},{"location":"api-reference/#debug_dojo._config_models.DebuggerType","title":"<code>DebuggerType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for different types of debuggers.</p> Source code in <code>src/debug_dojo/_config_models.py</code> <pre><code>class DebuggerType(Enum):\n    \"\"\"Enum for different types of debuggers.\"\"\"\n\n    DEBUGPY = \"debugpy\"\n    IPDB = \"ipdb\"\n    PDB = \"pdb\"\n    PUDB = \"pudb\"\n</code></pre>"},{"location":"api-reference/#debug_dojo._config_models.DebuggersConfig","title":"<code>DebuggersConfig</code>  <code>dataclass</code>","text":"<p>Configuration for debuggers.</p> Source code in <code>src/debug_dojo/_config_models.py</code> <pre><code>@dataclass\nclass DebuggersConfig:\n    \"\"\"Configuration for debuggers.\"\"\"\n\n    default: DebuggerType = DebuggerType.IPDB\n    \"\"\"Default debugger to use.\"\"\"\n    prompt_name: str = \"debug-dojo&gt; \"\n    \"\"\"Prompt name for the debugger, used in the REPL.\"\"\"\n\n    debugpy: DebugpyConfig = field(default_factory=DebugpyConfig)\n    \"\"\"Configuration for debugpy debugger.\"\"\"\n    ipdb: IpdbConfig = field(default_factory=IpdbConfig)\n    \"\"\"Configuration for ipdb debugger.\"\"\"\n    pdb: PdbConfig = field(default_factory=PdbConfig)\n    \"\"\"Configuration for pdb debugger.\"\"\"\n    pudb: PudbConfig = field(default_factory=PudbConfig)\n    \"\"\"Configuration for pudb debugger.\"\"\"\n</code></pre>"},{"location":"api-reference/#debug_dojo._config_models.DebuggersConfig.debugpy","title":"<code>debugpy = field(default_factory=DebugpyConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Configuration for debugpy debugger.</p>"},{"location":"api-reference/#debug_dojo._config_models.DebuggersConfig.default","title":"<code>default = DebuggerType.IPDB</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default debugger to use.</p>"},{"location":"api-reference/#debug_dojo._config_models.DebuggersConfig.ipdb","title":"<code>ipdb = field(default_factory=IpdbConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Configuration for ipdb debugger.</p>"},{"location":"api-reference/#debug_dojo._config_models.DebuggersConfig.pdb","title":"<code>pdb = field(default_factory=PdbConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Configuration for pdb debugger.</p>"},{"location":"api-reference/#debug_dojo._config_models.DebuggersConfig.prompt_name","title":"<code>prompt_name = 'debug-dojo&gt; '</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Prompt name for the debugger, used in the REPL.</p>"},{"location":"api-reference/#debug_dojo._config_models.DebuggersConfig.pudb","title":"<code>pudb = field(default_factory=PudbConfig)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Configuration for pudb debugger.</p>"},{"location":"api-reference/#debug_dojo._config_models.DebugpyConfig","title":"<code>DebugpyConfig</code>  <code>dataclass</code>","text":"<p>Configuration for debugpy debugger.</p> Source code in <code>src/debug_dojo/_config_models.py</code> <pre><code>@dataclass\nclass DebugpyConfig:\n    \"\"\"Configuration for debugpy debugger.\"\"\"\n\n    host: str = \"localhost\"\n    \"\"\"Host for debugpy debugger.\"\"\"\n    log_to_file: bool = False\n    \"\"\"Whether to log debugpy output to a file.\"\"\"\n    port: int = 1992\n    \"\"\"Port for debugpy debugger.\"\"\"\n    wait_for_client: bool = True\n    \"\"\"Whether to wait for the client to connect before starting debugging.\"\"\"\n\n    @property\n    def set_trace_hook(self) -&gt; str:\n        return \"debugpy.breakpoint\"\n</code></pre>"},{"location":"api-reference/#debug_dojo._config_models.DebugpyConfig.host","title":"<code>host = 'localhost'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Host for debugpy debugger.</p>"},{"location":"api-reference/#debug_dojo._config_models.DebugpyConfig.log_to_file","title":"<code>log_to_file = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to log debugpy output to a file.</p>"},{"location":"api-reference/#debug_dojo._config_models.DebugpyConfig.port","title":"<code>port = 1992</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Port for debugpy debugger.</p>"},{"location":"api-reference/#debug_dojo._config_models.DebugpyConfig.wait_for_client","title":"<code>wait_for_client = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to wait for the client to connect before starting debugging.</p>"},{"location":"api-reference/#debug_dojo._config_models.ExceptionsConfig","title":"<code>ExceptionsConfig</code>  <code>dataclass</code>","text":"<p>Configuration for exceptions handling.</p> Source code in <code>src/debug_dojo/_config_models.py</code> <pre><code>@dataclass\nclass ExceptionsConfig:\n    \"\"\"Configuration for exceptions handling.\"\"\"\n\n    locals_in_traceback: bool = False\n    \"\"\"Include local variables in traceback.\"\"\"\n    post_mortem: bool = True\n    \"\"\"Enable post-mortem debugging after an exception.\"\"\"\n    rich_traceback: bool = True\n    \"\"\"Enable rich traceback for better error reporting.\"\"\"\n</code></pre>"},{"location":"api-reference/#debug_dojo._config_models.ExceptionsConfig.locals_in_traceback","title":"<code>locals_in_traceback = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Include local variables in traceback.</p>"},{"location":"api-reference/#debug_dojo._config_models.ExceptionsConfig.post_mortem","title":"<code>post_mortem = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enable post-mortem debugging after an exception.</p>"},{"location":"api-reference/#debug_dojo._config_models.ExceptionsConfig.rich_traceback","title":"<code>rich_traceback = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enable rich traceback for better error reporting.</p>"},{"location":"api-reference/#debug_dojo._config_models.Features","title":"<code>Features</code>  <code>dataclass</code>","text":"<p>Legacy configuration for installing debug features (used in V1 config).</p> Source code in <code>src/debug_dojo/_config_models.py</code> <pre><code>@dataclass\nclass Features:\n    \"\"\"Legacy configuration for installing debug features (used in V1 config).\"\"\"\n\n    rich_inspect: bool = True\n    \"\"\"Install rich inspect as 'i' for enhanced object inspection.\"\"\"\n    rich_print: bool = True\n    \"\"\"Install rich print as 'p' for enhanced printing.\"\"\"\n    rich_traceback: bool = True\n    \"\"\"Install rich traceback for better error reporting.\"\"\"\n    comparer: bool = True\n    \"\"\"Install comparer as 'c' for side-by-side object comparison.\"\"\"\n    breakpoint: bool = True\n    \"\"\"Install breakpoint as 'b' for setting breakpoints in code.\"\"\"\n</code></pre>"},{"location":"api-reference/#debug_dojo._config_models.Features.breakpoint","title":"<code>breakpoint = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Install breakpoint as \u2018b\u2019 for setting breakpoints in code.</p>"},{"location":"api-reference/#debug_dojo._config_models.Features.comparer","title":"<code>comparer = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Install comparer as \u2018c\u2019 for side-by-side object comparison.</p>"},{"location":"api-reference/#debug_dojo._config_models.Features.rich_inspect","title":"<code>rich_inspect = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Install rich inspect as \u2018i\u2019 for enhanced object inspection.</p>"},{"location":"api-reference/#debug_dojo._config_models.Features.rich_print","title":"<code>rich_print = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Install rich print as \u2018p\u2019 for enhanced printing.</p>"},{"location":"api-reference/#debug_dojo._config_models.Features.rich_traceback","title":"<code>rich_traceback = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Install rich traceback for better error reporting.</p>"},{"location":"api-reference/#debug_dojo._config_models.FeaturesConfig","title":"<code>FeaturesConfig</code>  <code>dataclass</code>","text":"<p>Configuration for installing debug features.</p> Source code in <code>src/debug_dojo/_config_models.py</code> <pre><code>@dataclass\nclass FeaturesConfig:\n    \"\"\"Configuration for installing debug features.\"\"\"\n\n    breakpoint: str = \"b\"\n    \"\"\"Install breakpoint as 'b' for setting breakpoints in code.\"\"\"\n    comparer: str = \"c\"\n    \"\"\"Install comparer as 'c' for side-by-side object comparison.\"\"\"\n    rich_inspect: str = \"i\"\n    \"\"\"Install rich inspect as 'i' for enhanced object inspection.\"\"\"\n    rich_print: str = \"p\"\n    \"\"\"Install rich print as 'p' for enhanced printing.\"\"\"\n</code></pre>"},{"location":"api-reference/#debug_dojo._config_models.FeaturesConfig.breakpoint","title":"<code>breakpoint = 'b'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Install breakpoint as \u2018b\u2019 for setting breakpoints in code.</p>"},{"location":"api-reference/#debug_dojo._config_models.FeaturesConfig.comparer","title":"<code>comparer = 'c'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Install comparer as \u2018c\u2019 for side-by-side object comparison.</p>"},{"location":"api-reference/#debug_dojo._config_models.FeaturesConfig.rich_inspect","title":"<code>rich_inspect = 'i'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Install rich inspect as \u2018i\u2019 for enhanced object inspection.</p>"},{"location":"api-reference/#debug_dojo._config_models.FeaturesConfig.rich_print","title":"<code>rich_print = 'p'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Install rich print as \u2018p\u2019 for enhanced printing.</p>"},{"location":"api-reference/#debug_dojo._config_models.IpdbConfig","title":"<code>IpdbConfig</code>  <code>dataclass</code>","text":"<p>Configuration for ipdb debugger.</p> Source code in <code>src/debug_dojo/_config_models.py</code> <pre><code>@dataclass\nclass IpdbConfig:\n    \"\"\"Configuration for ipdb debugger.\"\"\"\n\n    context_lines: int = 20\n    \"\"\"Number of context lines to show in ipdb.\"\"\"\n\n    @property\n    def set_trace_hook(self) -&gt; str:\n        return \"ipdb.set_trace\"\n</code></pre>"},{"location":"api-reference/#debug_dojo._config_models.IpdbConfig.context_lines","title":"<code>context_lines = 20</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of context lines to show in ipdb.</p>"},{"location":"api-reference/#debug_dojo._config_models.PdbConfig","title":"<code>PdbConfig</code>  <code>dataclass</code>","text":"<p>Configuration for pdb debugger.</p> Source code in <code>src/debug_dojo/_config_models.py</code> <pre><code>@dataclass\nclass PdbConfig:\n    \"\"\"Configuration for pdb debugger.\"\"\"\n\n    @property\n    def set_trace_hook(self) -&gt; str:\n        return \"pdb.set_trace\"\n</code></pre>"},{"location":"api-reference/#debug_dojo._config_models.PudbConfig","title":"<code>PudbConfig</code>  <code>dataclass</code>","text":"<p>Configuration for pudb debugger.</p> Source code in <code>src/debug_dojo/_config_models.py</code> <pre><code>@dataclass\nclass PudbConfig:\n    \"\"\"Configuration for pudb debugger.\"\"\"\n\n    @property\n    def set_trace_hook(self) -&gt; str:\n        return \"pudb.set_trace\"\n</code></pre>"},{"location":"api-reference/#debug_dojo._cli.ExecMode","title":"<code>ExecMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Execution mode for the target.</p> Source code in <code>src/debug_dojo/_cli.py</code> <pre><code>class ExecMode(Enum):\n    \"\"\"Execution mode for the target.\"\"\"\n\n    FILE = \"file\"\n    MODULE = \"module\"\n    EXECUTABLE = \"executable\"\n</code></pre>"},{"location":"api-reference/#debug_dojo._cli.__execute_with_debug","title":"<code>__execute_with_debug(target_name, target_args, *, target_mode, verbose, config)</code>","text":"<p>Execute a target script or module with installed debugging tools.</p> <p>Parameters:</p> Name Type Description Default <code>target_name</code> <code>str</code> <p>The name of the script, module, or executable to run.</p> required <code>target_args</code> <code>list[str]</code> <p>Arguments to pass to the target.</p> required <code>target_mode</code> <code>ExecMode</code> <p>The execution mode (FILE, MODULE, or EXECUTABLE).</p> required <code>verbose</code> <code>bool</code> <p>If True, print verbose output.</p> required <code>config</code> <code>DebugDojoConfig</code> <p>The debug-dojo configuration.</p> required <p>Raises:</p> Type Description <code>Exit</code> <p>If the target file is not found, or if an import error occurs,         or if the script exits with a non-zero code.</p> Source code in <code>src/debug_dojo/_cli.py</code> <pre><code>def __execute_with_debug(  # noqa: C901\n    target_name: str,\n    target_args: list[str],\n    *,\n    target_mode: ExecMode,\n    verbose: bool,\n    config: DebugDojoConfig,\n) -&gt; None:\n    \"\"\"Execute a target script or module with installed debugging tools.\n\n    Args:\n        target_name (str): The name of the script, module, or executable to run.\n        target_args (list[str]): Arguments to pass to the target.\n        target_mode (ExecMode): The execution mode (FILE, MODULE, or EXECUTABLE).\n        verbose (bool): If True, print verbose output.\n        config (DebugDojoConfig): The debug-dojo configuration.\n\n    Raises:\n        typer.Exit: If the target file is not found, or if an import error occurs,\n                    or if the script exits with a non-zero code.\n\n    \"\"\"\n    sys.argv = [target_name, *target_args]\n\n    if verbose:\n        rich_print(f\"[blue]Installing debugging tools for {target_name}.[/blue]\")\n        rich_print(f\"[blue]Arguments for target: {target_args}[/blue]\")\n\n    install_by_config(config)\n\n    if target_mode is ExecMode.MODULE:\n        runner = runpy.run_module\n    else:\n        if target_mode is ExecMode.EXECUTABLE:\n            target_name = which(target_name) or target_name\n\n        if not Path(target_name).exists():\n            raise typer.Exit(1)\n\n        runner = runpy.run_path\n\n    try:\n        _ = runner(target_name, run_name=\"__main__\")\n    except ImportError as e:\n        rich_print(f\"[red]Error importing {target_name}:[/red]\\n{e}\")\n        raise typer.Exit(1) from e\n    except BdbQuit:\n        rich_print(\"[red]Debugging session terminated by user.[/red]\")\n        raise typer.Exit(0) from None\n    except KeyboardInterrupt:\n        rich_print(\"[red]Execution interrupted by user.[/red]\")\n        raise typer.Exit(0) from None\n    except SystemExit as e:\n        if e.code:\n            rich_print(f\"[red]Script exited with code {e.code}.[/red]\")\n    except Exception as e:\n        rich_print(f\"[red]Error while running {target_name}:[/red]\\n{e}\")\n        rich_print(traceback.format_exc())\n        if config.exceptions.post_mortem:\n            import ipdb  # pyright: ignore[reportMissingTypeStubs]  # noqa: PLC0415, T100\n\n            rich_print(\"[blue]Entering post-mortem debugging session...[/blue]\")\n            ipdb.post_mortem(e.__traceback__)  # pyright: ignore[reportUnknownMemberType]\n        raise typer.Exit(1) from e\n</code></pre>"},{"location":"api-reference/#debug_dojo._cli.main","title":"<code>main()</code>","text":"<p>Run the command-line interface.</p> Source code in <code>src/debug_dojo/_cli.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Run the command-line interface.\"\"\"\n    cli()\n</code></pre>"},{"location":"api-reference/#debug_dojo._cli.run_debug","title":"<code>run_debug(ctx, target_name=None, *, config_path=None, debugger=None, verbose=False, module=False, executable=False)</code>","text":"<p>Run a Python script, module, or executable with debug-dojo tools.</p> <p>This command acts as the main entry point for <code>debug-dojo</code>, allowing users to execute their code while automatically installing and configuring debugging tools based on the provided options or configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The Typer context object.</p> required <code>target_name</code> <code>str | None</code> <p>The path to the script, name of the module, or                       name of the executable to run. If not provided,                       the command will exit.</p> <code>None</code> <code>config_path</code> <code>Path | None</code> <p>Path to a custom configuration file                        (e.g., <code>dojo.toml</code>).</p> <code>None</code> <code>debugger</code> <code>DebuggerType | None</code> <p>Override the default debugger specified                             in the config.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Enable verbose output, showing loaded configuration             and installation steps.</p> <code>False</code> <code>module</code> <code>bool</code> <p>Treat <code>target_name</code> as a Python module to run            (e.g., <code>dojo -m my_package.my_module</code>).</p> <code>False</code> <code>executable</code> <code>bool</code> <p>Treat <code>target_name</code> as an executable command to run                (e.g., <code>dojo -e pytest</code>).</p> <code>False</code> <p>Raises:</p> Type Description <code>Exit</code> <p>If <code>--module</code> and <code>--exec</code> are used together, or if the target         cannot be executed, or if an error occurs during execution.</p> Source code in <code>src/debug_dojo/_cli.py</code> <pre><code>@cli.command(\n    help=\"Run a Python script or module with debugging tools installed.\",\n    no_args_is_help=True,\n    context_settings={\"allow_extra_args\": True, \"ignore_unknown_options\": True},\n)\ndef run_debug(  # noqa: PLR0913\n    ctx: typer.Context,\n    target_name: Annotated[\n        str | None, typer.Argument(help=\"The target script or module to debug.\")\n    ] = None,\n    *,\n    config_path: Annotated[\n        Path | None, typer.Option(\"--config\", \"-c\", help=\"Show configuration\")\n    ] = None,\n    debugger: Annotated[\n        DebuggerType | None,\n        typer.Option(\"--debugger\", \"-d\", help=\"Specify the debugger to use\"),\n    ] = None,\n    verbose: Annotated[\n        bool,\n        typer.Option(\"--verbose\", \"-v\", help=\"Enable verbose output\"),\n    ] = False,\n    module: Annotated[\n        bool,\n        typer.Option(\"--module\", \"-m\", help=\"Run a module\"),\n    ] = False,\n    executable: Annotated[\n        bool,\n        typer.Option(\"--exec\", \"-e\", help=\"Run a command\"),\n    ] = False,\n) -&gt; None:\n    \"\"\"Run a Python script, module, or executable with debug-dojo tools.\n\n    This command acts as the main entry point for `debug-dojo`, allowing users to\n    execute their code while automatically installing and configuring debugging tools\n    based on the provided options or configuration file.\n\n    Args:\n        ctx (typer.Context): The Typer context object.\n        target_name (str | None): The path to the script, name of the module, or\n                                  name of the executable to run. If not provided,\n                                  the command will exit.\n        config_path (Path | None): Path to a custom configuration file\n                                   (e.g., `dojo.toml`).\n        debugger (DebuggerType | None): Override the default debugger specified\n                                        in the config.\n        verbose (bool): Enable verbose output, showing loaded configuration\n                        and installation steps.\n        module (bool): Treat `target_name` as a Python module to run\n                       (e.g., `dojo -m my_package.my_module`).\n        executable (bool): Treat `target_name` as an executable command to run\n                           (e.g., `dojo -e pytest`).\n\n    Raises:\n        typer.Exit: If `--module` and `--exec` are used together, or if the target\n                    cannot be executed, or if an error occurs during execution.\n\n    \"\"\"\n    if module and executable:\n        rich_print(\n            \"[red]Error: --module and --command options are mutually exclusive.[/red]\"\n        )\n        raise typer.Exit(1)\n\n    mode = (\n        ExecMode.EXECUTABLE\n        if executable\n        else ExecMode.MODULE\n        if module\n        else ExecMode.FILE\n    )\n\n    config = load_config(config_path, verbose=verbose, debugger=debugger)\n\n    if verbose:\n        rich_print(f\"[blue]Using debug-dojo configuration: {config} [/blue]\")\n\n    if target_name:\n        __execute_with_debug(\n            target_name=target_name,\n            target_mode=mode,\n            target_args=ctx.args,\n            verbose=verbose,\n            config=config,\n        )\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v060-2025-11-27","title":"v0.6.0 (2025-11-27)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Integrate tach for architecture management.</li> <li>Widen dependency version ranges.</li> <li>Add 3.14 to supported Python versions.</li> <li>Switching to dacite for config loading.</li> <li>Unit tests for internal functions.</li> <li>Add coverage report.</li> <li>Added ASCII banner to CLI.</li> </ul>"},{"location":"changelog/#improvements","title":"Improvements","text":"<ul> <li>Gemini generated docs improvements.</li> <li>Project has 90% coverage.</li> <li>Precommit update-hooks.</li> <li>Upgrade environment.</li> <li>Disable tests that require user interaction; they break coverage reports.</li> <li>Separate tool configurations in repository.</li> <li>Document \u2018all-debuggers\u2019 optional dependency.</li> </ul>"},{"location":"changelog/#v050-2025-08-23","title":"v0.5.0 (2025-08-23)","text":"<p>release tag: v0.5.0</p>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>CLI tests.</li> <li>Fixes to configuration reading.</li> <li>Post-mortem debugging support with <code>ipdb</code>.</li> <li>Added <code>--exec</code> option to <code>dojo</code> command \u2013 debug dojo can now run arbitrary commands.</li> </ul>"},{"location":"changelog/#improvements_1","title":"Improvements","text":"<ul> <li>Project and docs cleanup.</li> <li>UV build.</li> <li>PyProject cleanup.</li> <li>Testing the CLI with typer\u2019s CLI runner and pytest fixtures.</li> <li>README and docs index alignment.</li> <li>Pre-commit CI and extending pre-commit config.</li> <li>Set up Dependabot.</li> <li>CI improvements.</li> </ul>"},{"location":"changelog/#v041-2025-08-10","title":"v0.4.1 (2025-08-10)","text":"<p>release tag: v0.4.1</p>"},{"location":"changelog/#improvements_2","title":"Improvements","text":"<ul> <li>Mkdocs documentation at debug dojo.</li> </ul>"},{"location":"changelog/#v040-2025-08-10","title":"v0.4.0 (2025-08-10)","text":"<p>release tag: v0.4.0</p>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>New configuration model <code>DebugDojoConfig</code> for better structure.</li> <li>Added support for <code>debugger</code> configuration in <code>dojo.toml</code>.</li> <li>Updated <code>dojo</code> command to include debugger type in command call.</li> <li>Configuration versioning allows for in-flight migration of old configurations.</li> </ul>"},{"location":"changelog/#improvements_3","title":"Improvements","text":"<ul> <li>Improved error handling in configuration loading.</li> <li>Improved catching errors from target execution.</li> </ul>"},{"location":"changelog/#v032-2025-07-28","title":"v0.3.2 (2025-07-28)","text":"<p>release tag: v0.3.2</p>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>New logo for the project.</li> <li>Typer used for CLI implementation.</li> <li>Dojo is configured via <code>dojo.toml</code> or <code>pyproject.toml</code>.</li> <li>Support for <code>debugpy</code> and <code>ipdb</code> for debugging.</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Fixed documentation and history.</li> </ul>"},{"location":"changelog/#v020-2025-07-20","title":"v0.2.0 (2025-07-20)","text":"<p>release tag: v0.2.0</p>"},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>Added <code>dojo</code> command for easy debugging setup.</li> <li>Added <code>p()</code> function for rich printing.</li> <li>Added history file for tracking changes.</li> </ul>"},{"location":"changelog/#improvements_4","title":"Improvements","text":"<ul> <li>Moved to <code>hatch</code> for building and packaging.</li> <li>Fixed <code>pyproject.toml</code> to point to GitHub repository as the homepage.</li> </ul>"},{"location":"changelog/#v010-2025-07-19","title":"v0.1.0 (2025-07-19)","text":"<p>release tag: v0.1.0</p>"},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>Initial module to install debugging tools.</li> <li>Debug mode utilities for PuDB, rich tracebacks, and object inspection.</li> </ul>"},{"location":"cli-reference/","title":"CLI Reference","text":""},{"location":"cli-reference/#usage","title":"Usage","text":"<p>Run your Python script with debugging tools enabled using the <code>debug-dojo</code> command:</p> <pre><code>dojo my_script.py\n</code></pre> <p>You can optionally set configuration, verbose mode, and specify the debugger type. Both script files and modules are supported:</p> <pre><code>dojo --debugger ipdb --config dojo.toml --verbose --module my_module\n</code></pre>"},{"location":"cli-reference/#dojo","title":"dojo","text":"<p>Run a Python script or module with debugging tools installed.</p>"},{"location":"cli-reference/#usage_1","title":"Usage","text":"<p><code>dojo [OPTIONS][TARGET_NAME]</code></p>"},{"location":"cli-reference/#arguments","title":"Arguments","text":"Name Description Required <code>[TARGET_NAME]</code> The target script or module to debug. No"},{"location":"cli-reference/#options","title":"Options","text":"Name Description Required Default <code>-c, \u2013config PATH</code> Show configuration No - <code>-d, \u2013debugger [debugpy|ipdb|pdb|pudb]</code> Specify the debugger to use No - <code>-v, \u2013verbose</code> Enable verbose output No - <code>-m, \u2013module</code> Run a module No - <code>-e, \u2013exec</code> Run a command No - <code>\u2013install-completion</code> Install completion for the current shell. No - <code>\u2013show-completion</code> Show completion for the current shell, to copy it or customize the installation. No - <code>\u2013help</code> Show this message and exit. No -"},{"location":"cli-reference/#commands","title":"Commands","text":"<p>No commands available</p>"},{"location":"configuration/","title":"Configuration","text":"<p>You can configure the debugging tools using a <code>dojo.toml</code> or <code>pyproject.toml</code> file. The configuration allows you to specify which debugger to use, enable or disable features, and set various options.</p> <p><code>debug-dojo</code> looks for configuration in the following order:</p> <ol> <li>A file specified by the <code>--config</code> CLI option.</li> <li><code>dojo.toml</code> in the current working directory.</li> <li><code>pyproject.toml</code> in the current working directory.</li> <li><code>dojo.toml</code> in the user\u2019s config directory (e.g., <code>~/.config/dojo.toml</code>).</li> </ol> <p>Example <code>dojo.toml</code>:</p> <pre><code>[debuggers]\n    default = \"ipdb\"\n    prompt_name = \"my-dojo&gt; \"\n\n    [debuggers.debugpy]\n        host = \"localhost\"\n        log_to_file = false\n        port = 1992\n        wait_for_client = true\n\n    [debuggers.ipdb]\n        context_lines = 20\n\n    # pdb and pudb have no specific configuration options currently\n\n[exceptions]\n    locals_in_traceback = false\n    post_mortem = true\n    rich_traceback = true\n\n[features]\n    breakpoint = \"b\" # Mnemonic for setting breakpoints\n    comparer = \"c\"   # Mnemonic for side-by-side object comparison\n    rich_inspect = \"i\" # Mnemonic for rich object inspection\n    rich_print = \"p\"   # Mnemonic for rich pretty printing\n\n    # To disable a feature, set its mnemonic to an empty string:\n    # comparer = \"\"\n</code></pre>"},{"location":"configuration/#configuration-sections","title":"Configuration Sections","text":""},{"location":"configuration/#debuggers","title":"<code>[debuggers]</code>","text":"<p>This section controls the behavior of the integrated debuggers.</p> <ul> <li><code>default</code> (string, default: <code>ipdb</code>): Specifies the default debugger to use when <code>debug-dojo</code> is invoked without a <code>--debugger</code> flag. Valid options are <code>debugpy</code>, <code>ipdb</code>, <code>pdb</code>, and <code>pudb</code>.</li> <li><code>prompt_name</code> (string, default: <code>debug-dojo&gt;</code>): Sets the prompt string displayed in the debugger\u2019s REPL.</li> </ul>"},{"location":"configuration/#debuggersdebugpy","title":"<code>[debuggers.debugpy]</code>","text":"<p>Specific settings for the <code>debugpy</code> debugger.</p> <ul> <li><code>host</code> (string, default: <code>localhost</code>): The host address for <code>debugpy</code> to listen on.</li> <li><code>log_to_file</code> (boolean, default: <code>false</code>): If <code>true</code>, <code>debugpy</code> will log its output to a file.</li> <li><code>port</code> (integer, default: <code>1992</code>): The port number <code>debugpy</code> will use for communication.</li> <li><code>wait_for_client</code> (boolean, default: <code>true</code>): If <code>true</code>, <code>debug-dojo</code> will pause execution and wait for a debugger client (e.g., VS Code) to connect before proceeding.</li> </ul>"},{"location":"configuration/#debuggersipdb","title":"<code>[debuggers.ipdb]</code>","text":"<p>Specific settings for the <code>ipdb</code> debugger.</p> <ul> <li><code>context_lines</code> (integer, default: <code>20</code>): The number of context lines to display around the current line in <code>ipdb</code>.</li> </ul>"},{"location":"configuration/#debuggerspdb-and-debuggerspudb","title":"<code>[debuggers.pdb]</code> and <code>[debuggers.pudb]</code>","text":"<p>Currently, <code>pdb</code> and <code>pudb</code> do not have specific configurable options beyond their default behavior.</p>"},{"location":"configuration/#exceptions","title":"<code>[exceptions]</code>","text":"<p>This section configures how <code>debug-dojo</code> handles exceptions.</p> <ul> <li><code>locals_in_traceback</code> (boolean, default: <code>false</code>): If <code>true</code>, local variables will be included in the traceback output, providing more context for errors.</li> <li><code>post_mortem</code> (boolean, default: <code>true</code>): If <code>true</code>, <code>debug-dojo</code> will automatically enter a post-mortem debugging session (using the configured debugger) when an unhandled exception occurs.</li> <li><code>rich_traceback</code> (boolean, default: <code>true</code>): If <code>true</code>, tracebacks will be rendered using <code>rich</code>, providing colorized and more readable output.</li> </ul>"},{"location":"configuration/#features","title":"<code>[features]</code>","text":"<p>This section allows you to customize the mnemonics (short names) for the <code>debug-dojo</code> helper functions that are injected into builtins when <code>debug_dojo.install</code> is used. Setting a mnemonic to an empty string (<code>\"\"</code>) will disable that feature.</p> <ul> <li><code>breakpoint</code> (string, default: <code>b</code>): The mnemonic for the breakpoint function. (e.g., <code>b()</code>)</li> <li><code>comparer</code> (string, default: <code>c</code>): The mnemonic for the object comparison function. (e.g., <code>c(obj1, obj2)</code>)</li> <li><code>rich_inspect</code> (string, default: <code>i</code>): The mnemonic for the rich object inspection function. (e.g., <code>i(obj)</code>)</li> <li><code>rich_print</code> (string, default: <code>p</code>): The mnemonic for the rich pretty printing function. (e.g., <code>p(obj)</code>)</li> </ul>"},{"location":"development/","title":"Development and contributing","text":"<p>Project uses <code>poe</code> for defining and speeding up developer tasks.</p>"},{"location":"development/#environment-setup","title":"Environment setup","text":"<p>It\u2019s recommended to use <code>uv</code> for managing virtual environments. You can create a new environment with:</p> <pre><code>uv sync\n</code></pre> <p>This will create a new virtual environment in <code>.venv</code> folder and install all dependencies from <code>pyproject.toml</code>.</p> <p>You can activate the environment with:</p> <pre><code>./.venv/Scripts/activate  # Windows\nsource .venv/bin/activate  # Linux / macOS\n</code></pre> <p>If for some reason you don\u2019t want to use <code>uv</code>, there\u2019s a <code>requirements.txt</code> file generated from <code>pyproject.toml</code> that you can use to install dependencies with <code>pip</code>:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>The environment is kept up to date by dependabot, but you can also update dependencies manually with:</p> <pre><code>uv sync --upgrade\n</code></pre>"},{"location":"development/#lint-and-type-check","title":"Lint and type check","text":"<p>We\u2019re using <code>ruff</code> as formatter and linter and <code>basedpyright</code> for static type checking. You can run all three with simple command:</p> <pre><code>poe code-quality\n</code></pre>"},{"location":"development/#pre-commit-hooks","title":"Pre-commit hooks","text":"<p>Its recommended setting up <code>pre-commit</code> hooks to run quality checks before committing code.</p> <pre><code>pre-commit install\n</code></pre> <p>The project uses <code>pre-commit.ci</code> to automatically run checks on pull requests. If you don\u2019t have <code>pre-commit</code> installed locally, the checks will still run on the CI and possibly edit the code. This can lead to confusing situations where your code is modified after the PR is created.</p>"},{"location":"development/#tests","title":"Tests","text":"<p><code>Pytest</code> is used for testing. Tests include:</p> <ul> <li>docstring tests</li> <li>unit tests for internal functions</li> <li>integration tests for command line interface using <code>CLI Runner</code> from <code>Typer</code>.</li> </ul> <p>You can run all tests with:</p> <pre><code>poe test\n</code></pre> <p>(this is just a shortcut for <code>pytest</code> with some additional options).</p>"},{"location":"development/#contributing","title":"Contributing","text":"<p>You\u2019re welcome to contribute both new features and fixes. The above quality checks need to pass for a contribution to be accepted to <code>debug-dojo</code>. This is tested with Pull Requests job hook.</p>"},{"location":"fonts/","title":"Fonts","text":"<p>This directory contains fonts used in the documentation and assets.</p>"},{"location":"fonts/#zen-kaku-gothic-antique","title":"Zen Kaku Gothic Antique","text":"<ul> <li>Source: Google Fonts / GitHub</li> <li>License: Open Font License (OFL)</li> <li>File: <code>ZenKakuGothicAntique-Bold.ttf</code></li> </ul> <p>Downloaded for use in <code>docs/logo/banner.typ</code>.</p>"}]}